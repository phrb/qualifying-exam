\chapter{Case Studies}
\label{chap:usecases}

In this chapter we discuss our work with autotuning in different
High-Performance Computing domains. We present each study not chronologically,
but in an order that leads to the next research steps, which are presented in
chapter~\ref{chap:julia}. Each section of this chapter presents an autotuning
study in a different domain, with its own related work, search space and
autotuner implementation.

Section \ref{sec:paramSelGPU} presents our work using the OpenTuner framework
to select compiler flags for CUDA applications.  We published an initial
version~\cite{bruel2015autotuningGPU} of this study in the \textit{Simp√≥sio em
Sistemas Computacionais de Alto Desempenho} (WSCAD), and an extended
version~\cite{bruel2017autotuning} in the \textit{Concurrency and Computation:
Practice and Experience} (CCPE) journal.  This case study provided insight into
OpenTuner behaviour when applications have a \textit{small measurement time}.

Section \ref{sec:FPGA} presents our work with the OpenTuner framework for
selecting configuration parameters for a tool that generates FPGA hardware from
high-level C code.  We published this work~\cite{bruel2017autotuninghls} in the
\textit{International Conference on Reconfigurable Computing and FPGAs}
(ReConFig).  The compilation and measurement for applications in this study
took minutes to complete, and we were able to measure an order of magnitude
less configurations in comparison to the study with GPU compiler parameters.
This study provided insight into OpenTuner behaviour when applications have a
\textit{large measurement time}.

Section\ref{sec:autotuningCloud} presents our work with developing an extension
to the OpenTuner framework that enables it to perform measurements in public
distributed computing environments such as the \textit{Google Compute Engine}.
The extension follows the client-server model, and communication is done using
a protocol that we also developed. We submitted this study~\cite{bruel2016new}
to the \textit{Brazilian Symposium on Computer Networks and Distributed
Systems} (SBRC), but it was not accepted. This case study strengthened our
understanding of OpenTuner's shortcomings and motivated the implementation
of our parallel and distributed autotuning library in the Julia language.

Section \ref{sec:configDPE}, the final case study, presents our work with
autotuning hardware and software parameters for the \textit{Dot Product
Engine}, an experimental analog computer architecture. We published an initial
version~\cite{bruel2017generalize} of this work in the \textit{International
Conference on Rebooting Computing} (ICRC), and we plan to submit further
developments to the \textit{International Symposium on Computer Architecture}
(ISCA).

During the presentation of the case studies we discuss the different
application scenarios from the perspective of the time it takes to measure each
configuration generated by the autotuner. These discussions motivate the
implementation described in chapter~\ref{chap:julia}.
